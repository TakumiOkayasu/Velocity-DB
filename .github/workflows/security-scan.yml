name: Security Scan

on:
  # Manual trigger only to save minutes (remove daily schedule)
  workflow_dispatch:

# Cancel in-progress runs for the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Default permissions (read-only)
permissions:
  contents: read

jobs:
  # Semgrep: Fast pattern-based security scanning
  semgrep:
    name: Semgrep Security Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write

    steps:
      - uses: actions/checkout@v6

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install Semgrep
        run: pip install semgrep

      - name: Run Semgrep Scan
        run: |
          semgrep scan \
            --config=auto \
            --config=p/security-audit \
            --config=p/owasp-top-ten \
            --json \
            --output=semgrep-results.json \
            --exclude='node_modules' \
            --exclude='build' \
            --exclude='dist' \
            --exclude='third_party' \
            . || true

      - name: Create Issues from Semgrep Results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Check if results file exists
            if (!fs.existsSync('semgrep-results.json')) {
              console.log('No Semgrep results file found');
              return;
            }

            const results = JSON.parse(fs.readFileSync('semgrep-results.json', 'utf8'));
            const findings = results.results || [];

            console.log(`Found ${findings.length} issues`);

            // Get existing issues with semgrep label (both open and closed to avoid duplicates)
            const existingIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              labels: 'semgrep',
              per_page: 100
            });

            // Build set of existing issue identifiers (rule + file, without line number for stability)
            const existingIdentifiers = new Set(existingIssues.map(i => {
              // Extract rule and file from title: "[Semgrep] ruleName in path/file.ts:123"
              const match = i.title.match(/\[Semgrep\] (.+) in (.+):\d+$/);
              return match ? `${match[1]}:${match[2]}` : i.title;
            }));

            // Filter to high/medium severity only to reduce noise
            const significantFindings = findings.filter(f => {
              const severity = (f.extra?.severity || 'INFO').toUpperCase();
              return ['ERROR', 'WARNING', 'HIGH', 'MEDIUM', 'CRITICAL'].includes(severity);
            });

            console.log(`${significantFindings.length} significant findings to process`);

            // Limit to 10 issues per run to avoid rate limiting
            const maxIssuesPerRun = 10;
            let createdCount = 0;

            for (const finding of significantFindings) {
              if (createdCount >= maxIssuesPerRun) {
                console.log(`Reached limit of ${maxIssuesPerRun} issues per run`);
                break;
              }

              const ruleId = finding.check_id || 'unknown';
              const ruleName = ruleId.split('.').pop();
              const filePath = finding.path || 'unknown';
              const line = finding.start?.line || 0;

              // Create identifier for deduplication (without line number)
              const identifier = `${ruleName}:${filePath}`;

              // Skip if issue already exists (same rule + file)
              if (existingIdentifiers.has(identifier)) {
                console.log(`Skipping duplicate: ${ruleName} in ${filePath}`);
                continue;
              }

              const title = `[Semgrep] ${ruleName} in ${filePath}:${line}`;
              const severity = (finding.extra?.severity || 'medium').toLowerCase();
              const message = finding.extra?.message || 'No description available';
              const codeSnippet = finding.extra?.lines || '';
              const refs = finding.extra?.metadata?.references || [];

              const body = [
                '## Security Issue Detected by Semgrep',
                '',
                `**Rule ID:** \`${ruleId}\``,
                `**Severity:** ${severity}`,
                `**File:** \`${filePath}\``,
                `**Line:** ${line}`,
                '',
                '### Description',
                message,
                '',
                '### Affected Code',
                '```',
                codeSnippet,
                '```',
                '',
                '### References',
                refs.length > 0 ? refs.map(r => `- ${r}`).join('\n') : 'None',
                '',
                '---',
                '*This issue was automatically created by the security scan workflow.*'
              ].join('\n');

              // Determine priority label based on severity
              const priorityLabel = ['high', 'critical', 'error'].includes(severity)
                ? 'priority:high'
                : 'priority:medium';

              try {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: title,
                  body: body,
                  labels: ['semgrep', priorityLabel]
                });
                console.log(`Created issue: ${title}`);
                existingIdentifiers.add(identifier);
                createdCount++;
              } catch (error) {
                console.error(`Failed to create issue: ${error.message}`);
              }
            }

            console.log(`Created ${createdCount} new issues`)

  # CodeQL: Deep semantic analysis (optional, can be skipped)
  codeql:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
      contents: read

    strategy:
      fail-fast: false
      matrix:
        language: ['javascript-typescript']

    steps:
      - uses: actions/checkout@v6

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: ${{ matrix.language }}
          queries: security-extended

      - name: Setup Bun (for TypeScript)
        if: matrix.language == 'javascript-typescript'
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install frontend dependencies
        if: matrix.language == 'javascript-typescript'
        working-directory: frontend
        run: bun install --frozen-lockfile

      - name: Autobuild
        uses: github/codeql-action/autobuild@v4

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
        with:
          category: "/language:${{ matrix.language }}"
          upload: false

  # Summary job
  security-summary:
    name: Security Scan Summary
    runs-on: ubuntu-latest
    needs: [semgrep, codeql]
    if: always()
    steps:
      - name: Check scan results
        run: |
          echo "=== Security Scan Summary ==="
          echo "Semgrep: ${{ needs.semgrep.result }}"
          echo "CodeQL: ${{ needs.codeql.result }}"

          if [[ "${{ needs.semgrep.result }}" == "failure" ]] || \
             [[ "${{ needs.codeql.result }}" == "failure" ]]; then
            echo "One or more scans failed - check logs for details"
            exit 1
          fi

          echo "All security scans completed successfully"
